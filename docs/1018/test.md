# Test

2단계 마지막 정기 테스트 4문제 정리해보자.



## Problem 1

정수 n이 주어질 때, n보다 작거나 같은 자연수들 중 가장 큰 세제곱수를 구하는 함수를 작성하자.

n은 -1이상 100,000,000이하의 범위를 가진다.

### How to solve

자연수 중 세제곱수를 찾는 것이기 때문에 1부터 n이하의 범위를 돌면서 세제곱근이 자연수인 것을 찾을 때 마다 변수에 리셋시켜서 최종 값을 찾았다.

하지만 이런 경우에는 최악의 경우 1억번 확인하기 때문에 느리다.

```js
const solution = (n) => {
    let max = 0;
    for (let i = 1; i <= n; i++) {
        if (Math.cbrt(i) % 1 === 0) {
            max = i;
        }
    }
    return max;
};
```

n의 범위가 주어졌기 때문에 이를 이용해서 처음부터 세제곱근의 범위를 확인하면 훨씬 적은 시간에 확인이 가능하다.

1000의 세제곱이 10억이기 때문에 1부터 1000을 확인해서 반복문에서 n보다 i의 세제곱수가 커지면 i-1의 세제곱수를 리턴하여 반복문을 종료하면 된다.

n이 1억이라도 1000까지는 가지 않기 때문에 1000번보다도 적게 확인할 수가 있다.

```js
const solution = (n) => {
    for (let i = 1; i <= 1000; i++) {
        if (i ** 3 > n) {
            return (i - 1) ** 3;
        }
    }
};
```



## Problem 2

0부터 9까지의 숫자로 이루어진 문자열이 주어질 때, 숫자의 개수가 많은 순서대로 공백으로 구분하여 출력하자.

만약 숫자의 개수가 동일하면 작은 수를 먼저 출력한다.

문자열의 길이는 100000 이하 이다.

### How to solve

먼저 0부터 9까지의 숫자를 카운트한 결과값을 저장할 객체를 만들고 문자열을 반복문으로 돌면서 카운트한다.

저장된 객체를 정렬을 위해 배열로 변환하고 카운트 값을 기준으로 내림차순 정렬을 한다.

정렬된 배열에서 카운트 값을 제외시키고 공백으로 구분한 문자열로 변환하여 리턴하면 된다.

```js
const solution = (str) => {
    const dict = {
        0: 0,
        1: 0,
        2: 0,
        3: 0,
        4: 0,
        5: 0,
        6: 0,
        7: 0,
        8: 0,
        9: 0,
    };

    for (let i = 0; i < str.length; i++) {
        dict[str[i]]++;
    }

    const dictArr = Object.entries(dict);
    return dictArr
        .sort((a, b) => b[1] - a[1])
        .map((x) => x[0])
        .join(" ");
};
```

정렬과 카운트 값 제외는 길이가 10으로 고정이기 때문에 다른 방법과도 시간적으로는 비슷할 것이라 예상된다.



## Problem 3

h x w 개의 격자 형태의 게임판이 있다. 가장 끝의 왼쪽 상단이 시작 지점이고 오른쪽 하단이 종료 지점이다.

말을 시작 지점부터 종료 지점까지 이동시켜야 하는데 이 때 오른쪽이나 아래로만 이동이 가능하다.

말을 이동시키는 경우의 수를 출력하는 함수를 작성하자.

h와 w는 1이상 25이하의 자연수이다.

### How to solve

아래 예시로 격자 형태의 게임판이 있고 각 격자 마다 시작 지점으로부터 이동이 가능한 경우의 수가 있다.

2차원 배열로 보았을 때 행과 열이 0이 아닐 경우에 각 격자의 경우의 수는 왼쪽 한 칸 전의 경우의 수와 위쪽 한 칸 전의 경우의 수를 더한 것과 같다.

| 시작 지점 1 | 1    | 1    | 1    | 1            |
| ----------- | ---- | ---- | ---- | ------------ |
| 1           | 2    | 3    | 4    | 5            |
| 1           | 3    | 6    | 10   | 15           |
| 1           | 4    | 10   | 20   | 35           |
| 1           | 5    | 15   | 35   | 종료 지점 70 |

처음에는 자바스크립트에서 h x w 크기의 배열을 생성하면서 1로 채워넣어 놓으면 조금이지만 더 간단해지는데 이걸 생각 못했다.

이를 생각하고 구현한 코드는 아래와 같다.

```js
const solution = (h, w) => {
    const dp = Array.from({ length: h }, () => new Array(w).fill(1));
    for (let i = 1; i < h; i++) {
        for (let j = 1; j < w; j++) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }
    return dp[h - 1][w - 1];
};
```



## Problem 4

n층의 피라미드가 있다. 피라미드는 각 층마다 방이 있으며 n층에는 1개의 방이 있고 n-1층에는 2개의 방, 1층에는 n개의 방이 존재한다.

각 방에는 왼쪽 아래와 오른쪽 아래로 내려가는 계단이 있고 각 방에는 j개의 보석이 있다.

피라미드의 각 방에 존재하는 보석의 정보가 주어질 때 꼭대기에서 1층까지 내려오면서 구할 수 있는 보석의 최대 수를 구하는 함수를 작성하자.

층수 n은 1이상 100이하이고 보석 수 j는 1이상 1000이하이다.

### How to solve

각 층수를 반복문을 통해 방문하고 어느 방을 방문할지를 알려줄 변수 `loc` 과 보석을 저장할 `sum` 변수를 사용한다.

꼭대기는 방이 하나이므로 `n-1` 층부터 시작한다. 왼쪽 아래 방의 위치는 `loc` 이고 오른쪽 아래 방의 위치는 `loc+1` 이다.

오른쪽 아래 방의 보석이 더 많다면 `loc` 을 하나 늘려준다.

그리고 각 방의 보석 수를 `sum` 에 누적시키면 된다.

```js
const solution = (arr) => {
    let loc = 0,
        sum = arr[0][0];
    for (let i = 1; i < arr.length; i++) {
        if (arr[i][loc] < arr[i][loc + 1]) {
            loc++;
        }
        sum += arr[i][loc];
    }
    return sum;
};
```

