# Greedy

그리디 알고리즘은 동적 계획법과 마찬가지로 각 단계를 나누어 최종적으로 답을 찾아내는 형식의 비슷한 점이 있다.

하지만 그리디는 각 단계마다 지금 당장 가장 좋은 방법만을 선택한다는 점이 다르다.

이 기법은 매 순간 최적해를 찾지만 항상 최적해를 찾을 수 있는 것은 아니다.

그리디를 사용해도 항상 최적해를 구할 수 있는 문제의 경우 동적계획법보다 훨씬 빨라 이런 경우에 사용된다.

그리고 그리디는 상당히 직관적으로 풀어야 하기 때문에 연습이 필요하다.

하나의 예제를 통해 그리디를 살펴보자.

<br>

## Problem

프로그래머스 ["체육복" 문제 링크](https://programmers.co.kr/learn/courses/30/lessons/42862)

점심시간에 도둑이 들어, 일부 학생이 체육복을 도난당했다. 

다행히 여벌 체육복이 있는 학생이 이들에게 체육복을 빌려주려 한다. 

학생들의 번호는 체격 순으로 매겨져 있어, 바로 앞번호의 학생이나 바로 뒷번호의 학생에게만 체육복을 빌려줄 수 있다. 

예를 들어, 4번 학생은 3번 학생이나 5번 학생에게만 체육복을 빌려줄 수 있다.

체육복이 없으면 수업을 들을 수 없기 때문에 체육복을 적절히 빌려 최대한 많은 학생이 체육수업을 들어야 합니다.

체육수업을 들을 수 있는 학생의 최댓값을 return 하도록 solution 함수를 작성하자.

만약 여벌 체육복을 가져온 학생이 체육복을 도난 당했을 수 있는데 이 학생은 체육복을 하나만 도난 당했다고 가정하며, 다른 학생에게 체육복을 빌려줄 수 없다.

## solution

일단 처리해야 하는 과정이 있다.

먼저 여벌 체육복이 있지만 도난 당한 학생을 먼저 처리해야 하기 때문에 잃어버린 학생 배열과 여벌이 있는 학생 배열에서 없애준다.

만약 2번 학생이 도난당했다면 1번이나 3번이 가지고 있다면 무조건 작은 사람을 먼저 빌려입도록 하는 것이다.

하지만 모든 학생이 이러한 방식으로 빌려입기 위해서는 도난당한 학생도 사이즈가 작은 학생부터 빌려야하기 때문에 정렬과정이 필요하다.

```js
const solution = (n, lost, extra) => {
    // 여벌이 있고 도난도 당한 학생 처리
    const rLost = lost.filter((x) => !extra.includes(x));
    const rExtra = extra
        .filter((x) => !lost.includes(x))
        // 접근을 편하게 하기 위해서 객체에 여벌 체육복있는 학생을 저장
        .reduce((res, p) => {
            res[p] = true
            return res
        }, {})
    
    // 작은 사이즈 부터 처리하기 위해 정렬
    rLost.sort((a, b) => a - b)
    
    let count = n - rLost.length
    for (let i = 0; i < rLost.length; i++) {
        // 작은 사이즈 부터 카운트하고 없다면 큰 사이즈 카운트
        if (rExtra[rLost[i] - 1]) {
            count++
            rExtra[rLost[i] - 1] = false
        } else if (rExtra[rLost[i] + 1]) {
            count++
            rExtra[rLost[i] + 1] = false
        }
    }
    
    return count
}
```

연습의 필요성을 처음부터 느꼈지만 문제를 풀면서 더 느낄 수 있었다.

그리디에 익숙해지기 위해서는 조금 더 많은 문제를 접해보아야 할 것 같다.
