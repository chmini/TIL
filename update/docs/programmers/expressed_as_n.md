# Expressed as N

아래와 같이 5와 사칙연산만으로 12를 표현할 수 있다.

12 = 5 + 5 + (5 / 5) + 5 / 5

12 = 55 / 5 + 5 / 5

12 = (55 + 5) / 5

5를 사용한 횟수는 각각 6, 5, 4 이다. 그리고 이중 가장 작은 경우는 4이다.

이처럼 숫자 `N` 과 `number` 가 주어질 때, `N` 과 사칙연산만 사용해서 표현할 수 있는 방법 중 `N` 사용횟수의 최솟값을 리턴하는 함수를 작성하자.

- `N` 은 1 이상 9 이하이다.
- `number` 는 1 이상 32,000 이하이다.
- 수식에는 괄호와 사칙연산만 가능하며 나누기 연산에서 나머지는 무시한다.
- 최솟값이 8보다 크면 -1을 리턴한다.

<br>

## How to Solve

문제를 보자마자 `N` 의 사용 횟수마다 결과 값을 이용해서 값을 구해나가는 다이나믹이라고 생각했다.

만약 `N` 의 사용횟수가 4 라고 할 때의 경우의 수를 구해보자.

- 횟수 `1` 일 때의 결과 값과 횟수 `3` 일 때의 결과 값의 사칙 연산
- 횟수 `2` 일 때의 결과 값과 횟수 `2` 일 때의 결과 값의 사칙 연산
- 횟수 `3` 일 때의 결과 값과 횟수 `1` 일 때의 결과 값의 사칙 연산

이렇게 3가지의 경우가 존재하는데 처음에는 3번째 같은 1가지의 경우만 생각해서 조금 헤맸다.

코드에서는 중복되는 값을 무시했는데 1번과 3번같은 경우는 완전히 결과 값이 겹치는 데 이렇게 겹치는 계산 과정까지도 무시하면 좀 더 빠르게 푸는 것이 가능해보인다.

```js
const getValues = (a, b) => {
    return [a + b, a - b, a * b, Math.floor(a / b)];
};

const solution = (N, number) => {
    if (N === number) return 1;

    // 중복 값 무시를 위해 JS의 Set을 이용
    const dp = Array.from(
        { length: 9 },
        (_, i) => new Set([Number(String(N).repeat(i))])
    );

    for (let i = 2; i < 9; i++) {
        for (let j = 1; j < i; j++) {
            for (let num1 of dp[j]) {
                for (let num2 of dp[i - j]) {
                    getValues(num1, num2).forEach((v) => dp[i].add(v));
                }
            }
        }
        if (dp[i].has(number)) return i;
    }

    return -1;
};
```

풀 때 마다 느끼는 건데 dp문제는 재밌는 것 같다.
