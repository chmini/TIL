# Test Problem 4

테스트에서 조금만 더 빨리 알아차렸다면 4번까지는 풀 수 있었는데 너무 아쉽다.

테스트 시간 내에 풀지는 못했지만 `Dynamic Programming` 문제라 기록해두는 것이 좋을 것 같다.



## Description

A가 수직선 위에 서 있다. 그리고 A는 서 있는 지점에서 N미터 떨어진 목적지로 가려고 한다.

A는 한번에 수직선 위를 K 이하의 자연수 거리만큼 이동할 수 있으며, 처음 이동한 방향으로만 계속 이동할 수 있다.

그리고 직전에 이동한 거리와 같은 거리 만큼 다시 이동할 수 없다.

즉, 3-2-3 순서대로 이동했다면 다음에 3만큼 이동할 수 없다는 뜻이다.

이러한 규칙을 지키면서 이동할 때, 목적지에 도착 가능한 경로의 경우의 수는 얼마인지 구하자.

값이 너무 클 수 있으니 1,000,000,007로 나눈 나머지 값(나눈 값 또한 너무 클 수 있기 때문에 나머지로 제한함)을 구하자.



## How to solve

문제 보자마자 거스름돈 문제가 생각이 났다.

하지만 거스름돈 문제와 다른 점은 연속으로 같은 수가 올 수 없다는 점이다.

N이 5이고 K가 3일 때의 예시를 표를 통해 살펴보자.

DP문제는 작게 나누는 것부터가 시작이다.

가로는 N미터를 1단위로 나누었고 세로는 이동 거리 K를 1단위로 나누었다.

거스름 돈으로 보면 K가 화폐 단위이고 N이 거스름 돈이라고 볼 수 있다.

K로 갈 수 있는 경우의 수를 나누어 표시했다.

|      | 0     | 1     | 2     | 3                                                  | 4                                                            | 5                                                            |
| ---- | ----- | ----- | ----- | -------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 0    | 1 [0] | 0     | 0     | 0                                                  | 0                                                            | 0                                                            |
| 1    |       | 1 [1] | 0     | N = [3 - 1] 일 때 K != 1 인 경우의 수 **1** [1, 2] | N = [4 - 1] 일 때 K != 1 인 경우의 수 **2** [1, 3] [1, 2, 1] | N = [5 - 1] 일 때 K != 1 인 경우의 수 **1** [1, 3, 1]        |
| 2    |       |       | 1 [2] | N = [3 - 2] 일 때 K != 2 인 경우의 수 **1** [2, 1] | N = [4 - 2] 일 때 K != 2 인 경우의 수 **0**                  | N = [5 - 2] 일 때 K != 2 인 경우의 수 **2** [2, 1, 2] [2, 3] |
| 3    |       |       |       | N = [3 - 3] 일 때 K != 3 인 경우의 수 **1** [3]    | N = [4 - 3] 일 때 K != 3 인 경우의 수 **1** [3, 1]           | N = [5 - 3] 일 때 K != 3 인 경우의 수 **1** [3, 2]           |

N이 2이고 K가 1일 때 거스름 돈 같은 경우는 [1, 1] 일 때를 계산했지만 이 문제는 연속된 같은 수가 있으면 안되므로 제외한다.

N이 2일 때까지는 1가지로 초기 값처럼 정해져 있다.

N이 3일 때 부터 시작이다. N이 N - K 일 때의 경우의 수들 중에 K가 같은 경우를 제외한 경우의 합이 K가 바뀔 때 마다 적용된다. 

그래서 최종 경우의 수는 N이 5일 때 경우의 수를 합한 4가 되는 것이다.

코드로 구현 하면 아래와 같다.



## Code

```js
const solution = (n, k) => {
    // n가 0, 1, 2일 때는 정해져 있고 이를 이용해야 함
    const arr = [
        [1],
        [0, 1],
        [0, 0, 1],
        ...Array.from({ length: n - 2 }, () => [0]), // 나머지 부분을 k=0일 때 경우의 수 0을 가진 배열로 초기 설정
    ];
    // 3부터 계산
    for (let i = 3; i <= n; i++) {
        // 1부터 k까지 돌지만
        for (let j = 1; j <= k; j++) {
            // k가 i보다 커질 수 있기 때문에 break 걸어줌
            if (j > i) break;
           	// n-k 경우의 수 배열에서 k가 같은 경우를 제외한 합을 저장
            arr[i][j] = arr[i - j].reduce((sum, x, idx) => {
                idx !== j ? (sum += x) : sum;
                return sum;
            }, 0);
        }
    }
	// 최종 N일때 모든 경우의 수 합 리턴
    return arr[n].reduce((sum, x) => sum + x, 0) % 1000000007;
};
```



## Conclusion

처음부터 작게 나눈 문제들의 결과 값을 이용할 생각을 했어야 했는데 답답한 마음에 일일히 배열을 다 구해버려서 시간 복잡도도 초과에 가깝게 나왔는데 다시 풀어보니 DP문제에 대해서 이제 잘 풀 수 있을 듯 하다.