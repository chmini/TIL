#### 4. 전광판

**n**개의 문자를 보여주는 전광판이 있다.

전광판의 문자는 오른쪽에서 왼쪽으로 반복해서 흘러가며, 1초에 한 글자씩 흘러간다.

전광판에 띄울 문자 **s**와 시간 **t**가 주어질 때 **t**초의 전광판 문구를 출력해라.

**제한사항**

- 1 &leq; **n** &leq; 50
- 1 &leq; **s의 길이** &leq; 100
- 1 &leq;  **t** &leq; 1000
- 전광판의 공백은 `.` 으로 출력한다.

------

각 초마다 전광판에 띄울 문자열을 구해도 되지만

전광판의 크기에 상관없이 띄울 수 있는 문자열을 먼저 만든다.

이 문자열은 전광판 크기만큼의 공백 `.` 을 문자열 `s` 에 앞과 뒤에 붙여주면 된다.

문자열을 시간에 맞게 전광판의 크기만큼 자르면 정답이 나온다.

문자열을 자를 때 시작 **index**는 **s의 길이 + n**을 벗어나지 않는다.

전광판에 반복되어 흘러가기 때문에 시간에 **s의 길이 + n**를 나눈 나머지를 시작으로 자르면 된다.

```js
const solution = (n, s, t) => {
    return s
        .padStart(s.length + n, ".")
        .padEnd(s.length + n * 2, ".")
        .substr(t % (s.length + n), n);
}
```

<br>

#### 5. 단어 거꾸로 출력하기

알파벳 대소문자, 숫자 그리고 구분자 `.` `,` `!` `?` `공백` 으로 이뤄진 문장이 있다.

단어는 문장에서 구분자로 구분한다.

------

`split()` 으로 단어를 구분하고 각 단어를 뒤집어 리턴하면 정답이다.

```js
const solution = (s) => {
    return s
        .split(/[.,!? ]/g)
        .filter((x) => x !== "")
        .map((word) => word.split("").reverse().join(""));
}
```

<br>

#### 6. 가까운 버스 정류장

도시의 아파트에서 버스 정류장까지 거리를 구하려고 한다.

도시는 격자 모양의 지역으로 구분되어 있다.

아파트는 `1` 로 버스 정류장은 `0` 으로 표시되어 있다.

예를 들어, 3x3 크기의 도시가 주어질 때

|  1   |  0   |  1   |
| :--: | :--: | :--: |
|  1   |  1   |  1   |
|  1   |  1   |  1   |

각 아파트에서 가까운 버스정류장까지의 거리를 나타내는 결과는 아래와 같다.

|  1   |  0   |  1   |
| :--: | :--: | :--: |
|  2   |  1   |  2   |
|  3   |  2   |  3   |

**제한사항**

- 아파트에서 버스 정류장으로 이동은 상하좌우로만 이동할 수 있다. 대각선으로는 이동이 불가하다.
- 도시에서 버스 정류장은 적어도 하나 이상 존재한다.
- 도시에는 아파트와 버스 정류장만 존재한다.

------

먼저 버스 정류장의 좌표만 따로 모았다.

최단 거리를 입력할 배열 공간 `map` 을 만들었다.

도시를 돌면서 아파트를 보면 가지고 있는 버스 정류장 좌표와 모두 비교해서 가장 가까운 거리를 `map` 에 저장하고 `map` 을 리턴해주면 정답이다.

이것보다 더 좋은 풀이가 있을 것 같은데 한 번 고민해보는 것이 좋을 것 같다.

```js
const solution = (city) => {
    const bus = [];
    for (let i = 0; i < city.length; i++) {
        for (let j = 0; j < city[i].length; j++) {
            if (city[i][j] === 0) {
                bus.push([i, j]);
            }
        }
    }

    const map = Array.from(
        { length: city.length },
        (_, i) => new Array(city[i].length)
    );
    for (let i = 0; i < city.length; i++) {
        for (let j = 0; j < city[i].length; j++) {
            if (city[i][j] === 1) {
                let minDist = 100;
                for (let k = 0; k < bus.length; k++) {
                    const dist =
                        Math.abs(bus[k][0] - i) + Math.abs(bus[k][1] - j);
                    if (minDist > dist) {
                        minDist = dist;
                    } else {
                        minDist = minDist;
                    }
                }
                map[i][j] = minDist;
            } else {
                map[i][j] = 0;
            }
        }
    }
    return map;
}
```

